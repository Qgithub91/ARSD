rm(list = ls())

pacman::p_load(tidyverse, igraph)
source("info.centrality.R")

meta <- readxl::read_xlsx("J:/rawdata/meta.xlsx", sheet = "meta") %>% 
  filter(regroup %in% c("H", "L")) %>% 
  select(sample, group) %>% 
  mutate(group = factor(group, levels = c("H", "L"), labels = c("High", "Low")))
otu.taxa <- read.table("J:/abundance_division/otu.taxa.tsv", header = T, row.names = 1, sep = "\t") %>% 
  select(otus, meta$sample, staxa) %>% 
  as.data.frame()
taxonomy <- readxl::read_xlsx("J:/rawdata/otu_table.xlsx", sheet = "taxonomy")  

# 数据处理及分类，去除低频率物种
# target.abundance <- "RT" # AT或RT
target.group <- "High"

otutab <- otu.taxa %>% 
  column_to_rownames("otus") %>% 
  select(meta[meta$group == target.group,]$sample)

otutab[is.na(otutab)]<-0
##keep 6 otus
counts<-rowSums(otutab>0)
otutab<-otutab[counts>=2,]

comm<-t(otutab)

cormatrix=matrix(0,ncol(comm),ncol(comm))

for (i in 1:ncol(comm)){
  for (j in i:ncol(comm)){
    speciesi<-sapply(1:nrow(comm),function(k){
      ifelse(comm[k,i]>0,comm[k,i],ifelse(comm[k,j]>0,0.01,NA))
    })
    speciesj<-sapply(1:nrow(comm),function(k){
      ifelse(comm[k,j]>0,comm[k,j],ifelse(comm[k,i]>0,0.01,NA))
    })
    corij<-cor(log(speciesi)[!is.na(speciesi)],log(speciesj)[!is.na(speciesj)])
    
    cormatrix[i,j]<-cormatrix[j,i]<-corij
    
  }}

row.names(cormatrix)<-colnames(cormatrix)<-colnames(comm) # if processed using MENAP, OTU order should match in the original OTU table and the correlation matrix downloaded from MENAP.

cormatrix2<-cormatrix*(abs(cormatrix)>=0.98)  #only keep links above the cutoff point
cormatrix2[is.na(cormatrix2)]<-0
cormatrix2[abs(cormatrix2) == 1] <- 0
diag(cormatrix2)<-0    #no links for self-self   
cormatrix2[abs(cormatrix2)>0]<-1 # adjacency matrix
g = graph_from_adjacency_matrix(as.matrix(cormatrix2), mode="undirected", weighted = NULL, diag = FALSE, add.colnames = NULL) # note: this graph contains isolated nodes.
## End 2) construct a graph from OTU table

## 3) read in the correlation matrix downloaded from MENAP to construct the graph
# cormatrix.input  <- matrix(0, 2567, 2567)
# cormatrix.input[row(cormatrix.input) >= col(cormatrix.input)] <- scan("input_files/CorrelationMatrix_Y14_W.txt")
# cormatrix <- t(cormatrix.input)
# cormatrix[abs(cormatrix)<0.8]<-0
# cormatrix[abs(cormatrix)>0]<-1 # adjacency matrix
# g = graph_from_adjacency_matrix(as.matrix(cormatrix), mode="upper", weighted = NULL, diag = FALSE, add.colnames = NULL) # note: this graph contains isolated nodes.
## End 3) read in the correlation matrix downloaded from MENAP to construct the graph
### End get graph

# remove isolated nodes
iso_node_id = which(degree(g)==0)
g2 = delete.vertices(g, iso_node_id) # graph without isolated nodes

#check node number and links
length(V(g2));length(E(g2))   

# calculate vulnerability of each node
node.vul<-info.centrality.vertex(g2)
max(node.vul)

node.vul.saving <- node.vul %>% 
  as.data.frame() %>% 
  mutate(treat = target.group) %>% 
  rename(node.vul = ".")

write.table(node.vul.saving, paste0(target.group, ".", format(Sys.time(), "%Y%m%d"), ".node.vul.tsv"), sep = "\t", row.names = F, quote = F)

